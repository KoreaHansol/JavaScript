//자바스크립트의 데이터 타입은 크게 두가지로 나뉜다.
//기본형 - 숫자, 문자, 불리언, null, undifined, ES6에서 심볼 추가
//참조형 - 객체, 배열, 함수, 날짜, 정규표현식, ES6에서 Map, WeakMap, Set, WeakSet
//기본형은 값이 담긴 주솟값을 바로 복제하고, 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다는 점이 다름

//var a; - 변할수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다. 변수는 결국 변경가능한 데이터가 담길수 있는 공간 또는 그릇

//var a = 'abc' 문자열 'abc' 데이터는 별도의 공간에 저장되고 그 문자열을 가리키는 주솟값이 변수 a에는 저장된다
//만약 문자열'abc' 가 'abcd'로 바뀐다면 'abcd'라는 문자열을 새로 만들어서 별도의 공간에 저장하고 그 주소를 변수공간에 연결한다.
//var a = 'abc', var b = 'abc' 여기서 a와 b는 같은 문자열을 가리키는 주소값이 저장된다.(만약 이렇게 하지 않으면 변수가 500개일때는 500개의 새로운 문자열을 생성해야한다.)
//결론은 중복된 데이터에 대한 처리 효율이 높아진다.

//변수와 상수를 구분하는 성질은 변경 가능성이다. 바꿀 수 있으면 변수, 바꿀 수 없으면 상수
//불변값과 상수는 다른 개념인데 변수와 상수를 구분짓는 변경 가능성의 대상은 변수 영역메모리, 한번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건
//반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역 메모리.

//불변성
var a = 'abc';
a = a + 'def'; //데이터공간에서 'abcdef' 를 찾고 없으므로 새로운 문자열을 만들어 그 주소를 변수 a에 저장
var b = 5;
var c = 5; //데이터 공간에서 5를 찾고 이미 만들어 놓은 값이 있으니 그 주소를 재활용 (중복데이터 처리 효율 up)




//참조형 데이터의 할당

var obj1 = {
    a: 1,
    b: 'bbb'
};

//변수 영역의 빈 공간을 확보하고, 그 주소의 이름을 obj1로 지정, 값은 @5001
//임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러개의 프로퍼티로 이뤄진 데이터 그룹.
// 이 그룹 내부에 프로퍼티를 저장하기 위해서 별도의 변수 영역을 마련하고 그 영역의 주소를 (@7103~?) @5001에 저장
//@7103및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정.
//데이터 영역에서 숫자 1을 검색해보니 검색 결과가 없음 그래서 임의로 @5003에 저장하고 이 주소를 프로퍼티를 저장하기 위해 별도로 마련한 변수 영역인 @7103에 저장
//문자열 'bbb'역시 임의로 @5004에 저장하고(데이터영역), 이 주소를 @7104에 저장 (변수영역)

//결론적으로 기본형데이터와의 차이는 객체의 변수(프로퍼티) 영역이 별도로 존재한다는 점임.
//객체가 별도로 할애한 영역은 변수 영역일 뿐이다 (프로퍼티를 위해). 그리고 데이터 영역은 결국 기존의 메모리 공간을 그대로 활용하고 있다.
//데이터 영역에 저장된 값은 모두 불변값이다. 그러나 변수에는 다른값을 얼마든지 대입할 수 있다(데이터영역에 새로 할당하고 이값을 대입하는것)
//그래서 참조형 데이터는 불변하지 않다!하고 말하는것.



//참조형 데이터의 프로퍼티 재할당
var obj1 = {
    a: 1,
    b: 'bbb'
};
obj1.a = 2;

//obj1의 a프로퍼티에 숫자 2를 할당하려고 함. 데이터영역에서 숫자 2를 검색.. 그런데 2는 없음.
//그러므로 빈공간인 @5005에 저장하고 이 주소를 변수영역인 @7103에 저장
//결론은 obj1가 바로보고 있는 주소는 변하지 않음. 기존의 객체 내부의 값만 바뀐것 (새로운 객체가 만들어진 것이 아니라 기존의 객체 내부의 값이 바뀜(프로퍼티가 바로보고 있는 주소가))


//중첩된 참조형 데이터(객체)의 프로퍼티 할당
var obj = {
    x: 3,
    arr: [3,4,5]
};

//우선 변수 영역의 빈공간 @1002를 확보하고, 그 주소의 이름은 obj로 저장
//임의의 데이터 저장공간 @5001에 데이터를 저장하려는데, 이 데이터는 여러개의 변수와 값들을 모아놓은 객체이다.
//이 객체의 각 변수들을 저장하기 위해 별도의 변수영역을 마련(@7103`?), 그 영영의 주소를 @5001에 저장
//프로퍼티를 위한 별도의 변수영역 @7103에 이름 x를, @7104에 이름 arr를 지정
//데이터 영역에서 숫자 3을 검색, 없으므로 임의로 @5002에 저장하고 이 주소를 @7103에 저장
//@7104에 저장할 값은 배열로서 역시 데이터 객체.. 이 객체 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련 (@8104~?) 그 영역의 주소 정보(@8104~?)를 @5003에 저장한 다음
//@5003을 @7104에 저장
//배열의 요소가 총 3개이므로 3개의 변수 공간을 확보하고 각각 인덱스를 부여
//데이터 영역에서 숫자 3을 검색한다.있으므로 이 주소를 @8104에 저장
//데이터 영역에 숫자 4와 5가 없으므로 각각 @5004, @5005에 저장하고 이 주소를 각각 @8105, @8106에 저장

//이제 obj.arr[1]을 검색 하려고 하면 메모리에서는 다음과 같은 검색 과정을 거침

//obj라는 식별자를 가진 주소를 찾는다 (@1002)
//값이 주소이므로 그 주소로 이동 (@5001 -> 데이터 영역에 있는 프로퍼티 주소)
//값이 주소이므로 (@5001에 들어있는것은 프로퍼티 주소 @7103~?) 그 주소로 이동
//arr이라는 식별자를 가진 주소를 찾는다 (@7104)
//값이 주소이므로 그 주소로 이동(@5003 -> 배열의 주소들의 집합)
//인덱스 1에 해당하는 주소를 찾는다 (@8105) 값이 주소이므로 그 주소로 이동 (@5004)
//값이 숫자형 데이터 이므로 4를 반환

//만약 이 상태에서 재할당 명령을 내린다면?
obj.arr = 'str'

//@5006에 문자열 'str'을 저장하고(데이터 영역을 검색했는데 str이란 문자열을 저장한 곳이 없으므로) 그 주소를 @7104에 저장한다.
//그러면 @5003은 더이상 자신의 주소를 참조하는 변수가 하나도 없게 된다.
//어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 참조 카운트라 하는데 0이 되면 가비지 컬렉터에 의해 수거 대상이 된다.
//수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.


//변수 복사
//기본형 데이터와 참조형 데이터의 차이

var a = 10;
var b = a;

var obj1 = {c: 10, d: 'ddd'};
var obj2 = obj1;
//기본형
//변수 영역의 빈공간 @1001을 확보하고 식별자를 a로 지정
//숫자 10을 데이터 영역에서 검색하고 없으므로 빈 공간 @5001에 지정한 다음, 이 주소를 @1001에 넣음 -> 기본형 데이터에 대한 변수 선언 및 할당 종료
//복사 - 변수 영역의 빈 공간 @1002를 확보하고 식별자를 b로 지정
//식별자 a를 검색해 그 값을 찾아와야 함. @1001에 저장된 값인 @5001을 들고 좀 전에 확보해둔 @1002에 값으로 대입

//참조형
//변수 영역의 빈 공간 @1003를 확보하고 식별자는 obj1로 지정
//데이터 영역의 빈 공간 @5002을 확보하고, 데이터 그룹이 담겨야 하기 때문에 별도의 변수 영역 @7103~?를 확보해 그 주소를 저장
//@7103에는 식별자 c를 @7104에는 식별자 d를 입력한 다음, c에 대입할 값 10을 데이터 영역에서 검색한다. @5001에 이미 저장돼 있으므로 이 주소를 @7103에 연결
//문자열인 'ddd'는 데이터 영역의 빈공간에 새로 만들어서 @7104에 연결 -> 참조형 데이터인 객체에 대한 변수 선언 및 할당 과정
//복사
//변수 영역의 빈 공간 @1004를 확보, 식별자는 obj2로 지정
//이제 식별자 obj1을 검색해서 그 값인 @5002를 들고, @1004에 값으로 대입
//변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일
//@1001과 @1002는 모두 값이 @5001이 됐고, @1003과 @1004에는 모두 값이 @5002가 됬다.
//복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에도 차이가 발생


//객체의 프로퍼티 변경 시
var a = 10;
var b = a;

var obj1 = {c: 10, d: 'ddd'};
var obj2 = obj1;

b = 15;
obj2.c = 20;

//데이터영역에 15가 없으므로 새로운 공간 @5004에 저장하고, 그 주소를 든 채로 변수 영역에서 식별자가 b인 주소를 찾음.
//데이터영역에 아직 20이 없으므로 새로운 공간 @5005에 저장하고, 그 주소를 든 채로 변수 영역에서 obj2를 찾고 obj2의 값인 @5002가 가리키는 변수
//영역에서 다시 c를 찾아 그곳에 @5005를 대입한다.
//결론적으로는 기본형데이터를 복사한 변수 b의 값을 바꿧더니 @1002의 값이 달라졌지만
//참조형 데이터를 복사한 변수 obj2의 프로퍼티의 값을 바꿧더니 객체를 바라보고 있는 주소 @1004의 값은 달라지지 않았다.
//obj1과 obj2는 결국 똑같은 객체를 바라보고 있다는 뜻이다.
//코드로 표현하면 a!==b , obj1 === obj2 이다
//기본형은 주솟값을 복사하는 과정이 한번만 이뤄지고, 참조형은 한단계를 더 거치게 된다는 차이다.

var obj1 = {c: 10, d: 'ddd'};
var obj2 = obj1;
obj2 = {c: 20, d: 'ddd'};
//이경우에는 obj2에 '새로운 객체를 할당'했기때문에 데이터영역에 새로운 공간에 새 객체가 저장되고 그 주소를 변수영역의 obj2의 위치에 저장한다.
//그래서 객체에 대한 변경임에도 값이 달라졌다.



//불변 객체를 만드는 간단한 방법
var user = {
    name: 'Kim',
    gender: 'male'
};

var changeName = function(user, newName) {
    var newUser = user;
    newUser.name = newName;
    return newUser;
};

var user2 = changeName(user,'He');

if(user !== user2){
    console.log('유저 정보가 변경되었습니다.');
}

console.log(user.name, user2.name);
console.log(user === user2);
//객체의 가변성으로 인한 문제점을 보여주는 코드이다.
//user객체를 생성하고 user2에 changeName으로 name프로퍼티를 바꾼 결과를 변수에 담는다.
//결론적으로는 user, user2는 같은 객체를 비라보게 된다. 그리고 user객체의 name은 He으로 바뀌어있게 된다.
//왜냐하면 참조형 데이터의 프로퍼티를 바꿀때는 한단계 더 거쳐서 바꾸기 때문에 user, user2는 같은 위치에 있기 때문이다.

var user = {
    name: 'Kim',
    gender: 'male'
};

var changeName = function(user, newName) {
    return {
        name: 'newName',
        gender: user.gender
    }
};

var user2 = changeName(user, 'He')
//이런식으로 새로운 객체를 반환해서 할당한다면 user과 user2는 서로 다른 객체 이므로 안전하게 변경된다.
//하지만 이런식으로는 정보가 많아지면 일일히 하드코딩 해야한다.

var copyObject = function(target) {
    var result = {};
    for (var prop in target) {
        result[prop] = target[prop];
    }
    return result;
}

var user = {
    name: 'kim',
    gender: 'male'
};

var user2 = copyObject(user);
user2.name = 'He'
//새로운 객체를 반환하는것은 위와 똑같고 달라진 점은 for in 으로 target(여기선user)안의 프로퍼티들을 result객체에 복사하는 것이다.
//하지만 얕은 복사

